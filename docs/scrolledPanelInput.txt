[HexAddressInput] (user typing)
      |
      V
[AddressSelect] component
      └── onChange(val) → handleHexInputChange(val, true)
              |
              V
[AssetSelectProvider context]
    ├── validHexInput (immediate, updates)
    ├── failedHexInput (if invalid)
    ├── debouncedHexInput (via useDebounce(validHexInput, 300ms))
    └── isValid (flag)

[debouncedHexInput] triggers:
      |
      V
useValidateFSMInput(debouncedHexInput)
      ├── skips if empty
      ├── if valid, starts validation chain:
      │       - check duplicate?
      │       - check if contract/account exists?
      │       - update inputState, validatedAsset
      └── on fail, sets inputState → EMPTY_INPUT, INVALID, etc.

[inputState + validatedAsset]
      └── flow back to:
      ├── AddressSelect (renders ErrorAssetPreview, RenderAssetPreview)
      ├── DataListSelect (with feedType)
      └── TokenListSelectPanel (closes if needed)

[Debug points]:
  ✅ HexAddressInput → console.log input
  ✅ handleHexInputChange → logs trimmed, isManual, isValid
  ✅ AssetSelectProvider → logs debouncedHexInput
  ✅ AddressSelect → logs before + after FSM hook
  ✅ useValidateFSMInput → logs ENTRY, skips, or errors
